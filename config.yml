<%-
def color_step(steps); ((((90.0 / 360.0) * 65536) * steps) % 65536).round; end
base_hue = 50_000

-%>
---
# The username for the Philips Hue Bridge(s).  You can either create one and
# set it here, or obtain generated ones and set them below.
common_username: &common_username "1234567890"
# The `max_connects`
max_connects: 3
bridges:
  # List all of your Philips Hue Bridge(s) here.  I suggest keeping the ID info
  # produced by `sm-discovery` in a comment next to the name so that when you're
  # setting things up on-site and all your bridges get new DHCP-assigned
  # addresses, you can quickly update the IP field here.
  "Bridge-01":
    id: "0017881226f3"
    ip: "192.168.2.10"
    username: *common_username
    debug_hue: <%= color_step(0) %>
    groups:
      Accent: 2
      AccentMain: 5 # All lights from Accent and Main
      Dance: 4
      Main: 1
      White: 3
  "Bridge-02":
    id: "001788105eda"
    ip: "192.168.2.6"
    username: *common_username
    debug_hue: <%= color_step(1) %>
    groups:
      Accent: 2
      AccentMain: 5 # All lights from Accent and Main
      Dance: 4
      Main: 1
      White: 3
  "Bridge-03":
    id: "0017881853d0"
    ip: "192.168.2.7"
    username: *common_username
    debug_hue: <%= color_step(2) %>
    groups:
      Dance: 1
      Main: 2
  "Bridge-04":
    id: "0017881a1d5c"
    ip: "192.168.2.9"
    username: *common_username
    debug_hue: <%= color_step(3) %>
    groups:
      Dance: 2
      Main: 1
light_groups:
  # Groups of lights for different purposes.
  #
  # The numeric portion is the ID as *assigned by the Philips Hue Bridge*.
  #
  # Main Lights is the group for which the main simulation will be applied.
  # It can be any number of lights from any number of bridges but you'll need to
  # plan groups out for saturation controls.
  # TODO: Break this into separate simulations per table?
  main_lights:
  - ["Bridge-01", 26, color]
  - ["Bridge-01", 37, color]
  - ["Bridge-01", 36, color]
  - ["Bridge-01", 38, color]
  - ["Bridge-01", 39, color]
  - ["Bridge-01", 40, color]
  - ["Bridge-01", 35, color]

  - ["Bridge-02", 12, color]
  - ["Bridge-02", 21, color]
  - ["Bridge-02", 20, color]
  - ["Bridge-02", 19, color]
  - ["Bridge-02", 15, color]
  - ["Bridge-02", 18, color]
  - ["Bridge-02", 11, color]

  - ["Bridge-03",  7, color]
  - ["Bridge-03",  2, color]
  - ["Bridge-03",  3, color]
  - ["Bridge-03",  8, color]
  - ["Bridge-03", 10, color]
  - ["Bridge-03",  9, color]
  - ["Bridge-03",  6, color]

  - ["Bridge-04",  7, color]
  - ["Bridge-04", 11, color]
  - ["Bridge-04", 12, color]
  - ["Bridge-04",  1, color]
  - ["Bridge-04",  9, color]
  - ["Bridge-04",  8, color]
  - ["Bridge-04",  5, color]
  # Dance Lights is the group of lights above the dance floor, which will
  # (ultimately) get their own simulation, although updates will be interleaved
  # with the main lights per-bridge.  It should be a positional map affording
  # spatial coherence.
  dance_lights:
  - ["Bridge-01", 41, color]
  - ["Bridge-01", 42, color]

  - ["Bridge-02", 22, color]
  - ["Bridge-02", 23, color]

  - ["Bridge-03", 11, color]
  - ["Bridge-03", 12, color]

  - ["Bridge-04", 13, color]
  - ["Bridge-04", 14, color]
  # Accent lights are just... other lights in the system.  Not part of any
  # simulation, they get their base color and that's it.
  accent_lights:
  - ["Bridge-01",  9, color]
  - ["Bridge-01", 10, color]
  - ["Bridge-01", 11, color]
  - ["Bridge-01", 12, color]
  - ["Bridge-01", 13, color]
  - ["Bridge-01", 33, color]
  - ["Bridge-01", 34, color]

  - ["Bridge-02",  7, color]
  - ["Bridge-02",  8, color]
  food_lights:
  # TODO: Allow specifying both a group ID and individual light IDs.  While we're at it, break this
  # TODO: out into a separate file, and use it as a cache -- with a way to regenerate from the
  # TODO: lights, and/or apply it to the lights.
  - ["Bridge-01",  3, white]
  - ["Bridge-01",  4, white]
  - ["Bridge-01",  5, white]
  - ["Bridge-01", 16, white]
  - ["Bridge-01", 24, white]
  - ["Bridge-01", 25, white]

  - ["Bridge-02",  4, white]
  - ["Bridge-02",  5, white]
  - ["Bridge-02",  6, white]
initial_state:
  # This defines what state the lights will be set to when running `sm-on`.
  # It's important you run `sm-on` *before* running `sparkle-motion`, as the
  # latter makes no attempt to actually switch lights on, or bring them into
  # a desired baseline state -- it merely assumes that they're in decent shape.
  hue: <%= base_hue %>
  sat: 255
  bri: 0
controllers:
  # Specify which controllers you want to use here.  You can refer to them via
  # the hash key later on.  Any field other than `class` is sent as a parameter
  # to the constructor, so if you want to control multiple Novation Launchpads,
  # for example, you could add a `name` attribute to differentiate them when
  # the code searches for the devices.
  #
  # At the moment there's some notable hard-coding and a generally poor
  # structural model for this stuff.  It needs a massive refactor.
  launchpad:
    class: SurfaceMaster::Launchpad::Interaction
  orbit:
    class: SurfaceMaster::Orbit::Interaction
  # This defines the color-swirl effect, per group.  It's a list of
  # steps, the time take (in seconds) LERPing from color to color, and the
  # time to wait between steps.
  #
  # Don't set wait much below 1.0!  ZigBee spec only allows 1 group
  # update/sec, but Hue Bridge/lights seem to be *mostly* OK with about 1
  # every 0.75 sec...
simulation:
  output:
    # This controls the amount of time (in seconds, but only to a precision of
    # 1/10th of a second) that it takes for the brightness of the lights to
    # change when they're updated.  If a new update comes along while the light
    # is still changing, then it will simply start moving from whatever
    # brightness it's currently at to the new value, again spread over the full
    # transition time.
    transition: 0.0
  nodes:
    perlin:
      # The speed parameter as a multiplier on `(x, time)` to map the Perlin
      # surface onto the lights.  Smaller values for the x component bring the
      # lights closer together on that surface, and larger ones move them
      # further apart.
      #
      # Similarly, smaller values for the y component cause the lights to move
      # down the surface more slowly as time passes -- and larger ones cause
      # quicker movement.
      #
      # Be mindful of how this plays out given how slow the Hue lights are to
      # update!
      #
      # NOTE: I'm ignoring octaves and persitence for the moment as the low
      # NOTE: precision for brightness and slow light updates make it easy for
      # NOTE: that to just get in the way.
      speed: [0.1, 4.0]
    contrast:
      # Performs a contrast-stretch on the Perlin noise generated above.
      # This has the effect of spreading the values out across the range of
      # brightnesses somewhat more evenly, as they'll tend to be centered
      # pretty heavily around 0.5 otherwise.
      #
      # Function: LINEAR, CUBIC, QUINTIC -- don't bother using iterations > 1
      # with LINEAR, as LINEAR is a no-op.
      #
      # The iteration count is how many times to stretch the value in successtion.
      function:   cubic
      iterations: 3
    spotlighting:
      base:     0.9
      exponent: 2
# TODO: Reallocate accent lights.
# TODO: Allow sweepers to address a particular *group or light* at each step.
# TODO: Allow arbitrary sweeper definitions.
# TODO: Simulation for dance lights.
# TODO: Simulation for accent lights.
# TODO: Either break white lights up across bridges, or consolidate them to Bridge-01 -- I'm... not really sure which.
# TODO: Intensity/saturation controls for dance lights.
# TODO: Intensity/saturation controls for accent lights.
# TODO: Brightness controls for eating lights.
# TODO: X/Y mapping of lights vs. simulation.
# TODO:   Is time Z, or do we still slide across X?
# TODO: Rearrange lights to evenly disperse A19s.
# TODO: Document bunching configuration on physical deployment.
# TODO: Document on-site validation process, including testing of all spotlighting positions.
# TODO: Document DHCP setup and use of nmap in case I forget Minbar again!!

# TODO: Group all writes to a particular bridge into a single thread.
# TODO: Either self-tune delays, or avoid sending refreshes to each light/group too fast?
# TODO: Play with X multiplier for Perlin component to see if that makes the lighting more visually interesting.
# TODO: Way to tweak output transition time on the fly?  Maybe make this part of the intensity?
# TODO: Way to tweak sweep transition time on the fly?  Maybe make this part of the intensity?
# TODO: De-duplicate the command queue before running it, and run it in a reliable way (E.G. retries with backoff)
# TODO:   If multiple entries exist in-queue for a bridge/group, collapse them together.

# TODO: Finish simulation visualization tool.  (Needs debugging!)
# TODO: Interactive tool for testing bulb positioning. (Be able to blink a specific light)
# TODO: Does Hue Bridge raw interface have any value here?
# TODO: Handy for persistence? http://ruby-doc.org/stdlib-2.2.3/libdoc/yaml/rdoc/YAML/Store.html
