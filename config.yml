<%-
def color_step(steps); ((((90.0 / 360.0) * 65536) * steps) % 65536).round; end
def random_color(steps); Random.rand(65536); end

base_hue    = 50_000
hue_spread  = 2_000
min_hue     = base_hue - hue_spread
max_hue     = base_hue + hue_spread

shared_sweep_transition = 0.5
shared_sweep_wait       = 2.0
-%>
---
# The username for the Philips Hue Bridge(s).  You can either create one and
# set it here, or obtain generated ones and set them below.
common_username: &common_username "1234567890"
# The `max_connects`
max_connects: 3
bridges:
  # List all of your Philips Hue Bridge(s) here.  I suggest keeping the ID info
  # produced by `sm-discovery` in a comment next to the name so that when you're
  # setting things up on-site and all your bridges get new DHCP-assigned
  # addresses, you can quickly update the IP field here.
  "Bridge-01":
    id: "0017881226f3"
    ip: "192.168.2.10"
    username: *common_username
    debug_hue: <%= color_step(0) %>
    groups:
      Accent: 2
      AccentMain: 5 # All lights from Accent and Main
      Dance: 4
      Main: 1
      White: 3
  "Bridge-02":
    id: "001788105eda"
    ip: "192.168.2.6"
    username: *common_username
    debug_hue: <%= color_step(1) %>
    groups:
      Accent: 2
      AccentMain: 5 # All lights from Accent and Main
      Dance: 4
      Main: 1
      White: 3
  "Bridge-03":
    id: "0017881853d0"
    ip: "192.168.2.7"
    username: *common_username
    debug_hue: <%= color_step(2) %>
    groups:
      Dance: 1
      Main: 2
  "Bridge-04":
    id: "0017881a1d5c"
    ip: "192.168.2.9"
    username: *common_username
    debug_hue: <%= color_step(3) %>
    groups:
      Dance: 2
      Main: 1
light_groups:
  # Groups of lights for different purposes.
  #
  # The numeric portion is the ID as *assigned by the Philips Hue Bridge*.
  #
  # Main Lights is the group for which the main simulation will be applied.
  # It can be any number of lights from any number of bridges but you'll need to
  # plan groups out for saturation controls.
  # TODO: Break this into separate simulations per table?
  main_lights:
    - ["Bridge-01", 26, color] # 0  -- Strand 1, Group 1
    - ["Bridge-01", 37, color] # 1  -- Strand 1, Group 1
    - ["Bridge-01", 36, color] # 2  -- Strand 1, Group 1
    - ["Bridge-01", 38, color] # 3  -- Strand 1, Group 1
    - ["Bridge-01", 39, color] # 4  -- Strand 1, Group 1
    - ["Bridge-01", 40, color] # 5  -- Strand 1, Group 1
    - ["Bridge-01", 35, color] # 6  -- Strand 1, Group 1
    - ["Bridge-01", 41, color] # 7  -- Dance Floor
    - ["Bridge-01", 42, color] # 8  -- Dance Floor

    - ["Bridge-02", 12, color] # 9  -- Strand 1, Group 2
    - ["Bridge-02", 21, color] # 10 -- Strand 1, Group 2
    - ["Bridge-02", 20, color] # 11 -- Strand 1, Group 2
    - ["Bridge-02", 19, color] # 12 -- Strand 1, Group 2
    - ["Bridge-02", 15, color] # 13 -- Strand 1, Group 2
    - ["Bridge-02", 18, color] # 14 -- Strand 1, Group 2
    - ["Bridge-02", 11, color] # 15 -- Strand 1, Group 2
    - ["Bridge-02", 22, color] # 16 -- Dance Floor
    - ["Bridge-02", 23, color] # 17 -- Dance Floor

    - ["Bridge-03",  7, color] # 18 -- Strand 2, Group 1
    - ["Bridge-03",  2, color] # 19 -- Strand 2, Group 1
    - ["Bridge-03",  3, color] # 20 -- Strand 2, Group 1
    - ["Bridge-03",  8, color] # 21 -- Strand 2, Group 1
    - ["Bridge-03", 10, color] # 22 -- Strand 2, Group 1
    - ["Bridge-03",  9, color] # 23 -- Strand 2, Group 1
    - ["Bridge-03",  6, color] # 24 -- Strand 2, Group 1
    - ["Bridge-03", 11, color] # 25 -- Dance Floor
    - ["Bridge-03", 12, color] # 26 -- Dance Floor

    - ["Bridge-04",  7, color] # 27 -- Strand 2, Group 2
    - ["Bridge-04", 11, color] # 28 -- Strand 2, Group 2
    - ["Bridge-04", 12, color] # 29 -- Strand 2, Group 2
    - ["Bridge-04",  1, color] # 30 -- Strand 2, Group 2
    - ["Bridge-04",  9, color] # 31 -- Strand 2, Group 2
    - ["Bridge-04",  8, color] # 32 -- Strand 2, Group 2
    - ["Bridge-04",  5, color] # 33 -- Strand 2, Group 2
    - ["Bridge-04", 13, color] # 34 -- Dance Floor
    - ["Bridge-04", 14, color] # 35 -- Dance Floor
  # Accent lights are just... other lights in the system.  Not part of any
  # simulation, they get their base color and that's it.
  accent_lights:
    - ["Bridge-01",  9, color]
    - ["Bridge-01", 10, color]
    - ["Bridge-01", 11, color]
    - ["Bridge-01", 12, color]
    - ["Bridge-01", 13, color]
    - ["Bridge-01", 33, color]
    - ["Bridge-01", 34, color]

    - ["Bridge-02",  7, color]
    - ["Bridge-02",  8, color]
  food_lights:
    # TODO: Allow specifying both a group ID and individual light IDs.  While we're at it, break this
    # TODO: out into a separate file, and use it as a cache -- with a way to regenerate from the
    # TODO: lights, and/or apply it to the lights.
    - ["Bridge-01",  3, white]
    - ["Bridge-01",  4, white]
    - ["Bridge-01",  5, white]
    - ["Bridge-01", 16, white]
    - ["Bridge-01", 24, white]
    - ["Bridge-01", 25, white]

    - ["Bridge-02",  4, white]
    - ["Bridge-02",  5, white]
    - ["Bridge-02",  6, white]
initial_state:
  # This defines what state the lights will be set to when running `sm-on`.
  # It's important you run `sm-on` *before* running `sparkle-motion`, as the
  # latter makes no attempt to actually switch lights on, or bring them into
  # a desired baseline state -- it merely assumes that they're in decent shape.
  hue: <%= base_hue %>
  #
  # Also, the values here are the values that the accent lights will hold for the whole evening:
  sat: 255
  bri: 63
controllers:
  # Specify which controllers you want to use here.  You can refer to them via
  # the hash key later on.  Any field other than `class` is sent as a parameter
  # to the constructor, so if you want to control multiple Novation Launchpads,
  # for example, you could add a `name` attribute to differentiate them when
  # the code searches for the devices.
  #
  # At the moment there's some notable hard-coding and a generally poor
  # structural model for this stuff.  It needs a massive refactor.
  launchpad:
    class: SurfaceMaster::Launchpad::Interaction
  orbit:
    class: SurfaceMaster::Orbit::Interaction
  # This defines the color-swirl effect, per group.  It's a list of
  # steps, the time take (in seconds) LERPing from color to color, and the
  # time to wait between steps.
  #
  # Don't set wait much below 1.0!  ZigBee spec only allows 1 group
  # update/sec, but Hue Bridge/lights seem to be *mostly* OK with about 1
  # every 0.75 sec...
color_configs:
  strand1_1:
    wedding: &strand1_1_wedding
      - <%= base_hue %>
      - <%= min_hue %>
      - <%= base_hue %>
      - <%= max_hue %>
    debug: &strand1_1_debug
      - <%= random_color(0) %>
      - <%= random_color(1) %>
      - <%= random_color(2) %>
      - <%= random_color(3) %>
      - <%= random_color(4) %>
      - <%= random_color(5) %>
      - <%= random_color(6) %>
      - <%= random_color(7) %>
  strand1_2:
    wedding: &strand1_2_wedding
      - <%= min_hue %>
      - <%= base_hue %>
      - <%= max_hue %>
      - <%= base_hue %>
    debug: &strand1_2_debug
      - <%= random_color(1) %>
      - <%= random_color(2) %>
      - <%= random_color(3) %>
      - <%= random_color(4) %>
      - <%= random_color(5) %>
      - <%= random_color(6) %>
      - <%= random_color(7) %>
      - <%= random_color(8) %>
  strand2_1:
    wedding: &strand2_1_wedding
      - <%= base_hue %>
      - <%= max_hue %>
      - <%= base_hue %>
      - <%= min_hue %>
    debug: &strand2_1_debug
      - <%= random_color(2) %>
      - <%= random_color(3) %>
      - <%= random_color(4) %>
      - <%= random_color(5) %>
      - <%= random_color(6) %>
      - <%= random_color(7) %>
      - <%= random_color(8) %>
      - <%= random_color(9) %>
  strand2_2:
    wedding: &strand2_2_wedding
      - <%= max_hue %>
      - <%= base_hue %>
      - <%= min_hue %>
      - <%= base_hue %>
    debug: &strand2_2_debug
      - <%= random_color(3) %>
      - <%= random_color(4) %>
      - <%= random_color(5) %>
      - <%= random_color(6) %>
      - <%= random_color(7) %>
      - <%= random_color(8) %>
      - <%= random_color(9) %>
      - <%= random_color(10) %>
  dance:
    wedding: &dance_wedding
      - <%= max_hue %>
      - <%= min_hue %>
      - <%= base_hue %>
      - <%= min_hue %>
    debug: &dance_debug
      - <%= random_color(4) %>
      - <%= random_color(5) %>
      - <%= random_color(6) %>
      - <%= random_color(7) %>
      - <%= random_color(8) %>
      - <%= random_color(9) %>
      - <%= random_color(10) %>
      - <%= random_color(11) %>
sweepers:
  - name: "Strand1Group1"
    targets:
      - [Bridge-01, AccentMain]
    transition: <%= shared_sweep_transition %>
    wait:       <%= shared_sweep_wait %>
    values: *strand1_1_wedding
  - name: "Strand1Group2"
    targets:
      - [Bridge-02, AccentMain]
    transition: <%= shared_sweep_transition %>
    wait:       <%= shared_sweep_wait %>
    values: *strand1_2_wedding
  - name: "Strand2Group1"
    targets:
      - [Bridge-03, Main]
    transition: <%= shared_sweep_transition %>
    wait:       <%= shared_sweep_wait %>
    values: *strand2_1_wedding
  - name: "Strand2Group2"
    targets:
      - [Bridge-04, Main]
    transition: <%= shared_sweep_transition %>
    wait:       <%= shared_sweep_wait %>
    values: *strand2_2_wedding
  - name: "Dance"
    targets:
      - [Bridge-01, Dance]
      - [Bridge-02, Dance]
      - [Bridge-03, Dance]
      - [Bridge-04, Dance]
    transition: 0.1
    wait:       1.0
    values: *dance_wedding
simulation:
  nodes:
    perlin:
      # The speed parameter as a multiplier on `(x, time)` to map the Perlin
      # surface onto the lights.  Smaller values for the x component bring the
      # lights closer together on that surface, and larger ones move them
      # further apart.
      #
      # Similarly, smaller values for the y component cause the lights to move
      # down the surface more slowly as time passes -- and larger ones cause
      # quicker movement.
      #
      # Be mindful of how this plays out given how slow the Hue lights are to
      # update!
      #
      # NOTE: I'm ignoring octaves and persitence for the moment as the low
      # NOTE: precision for brightness and slow light updates make it easy for
      # NOTE: that to just get in the way.
      speed: [0.1, 4.0]
    contrast:
      # Performs a contrast-stretch on the Perlin noise generated above.
      # This has the effect of spreading the values out across the range of
      # brightnesses somewhat more evenly, as they'll tend to be centered
      # pretty heavily around 0.5 otherwise.
      #
      # Function: LINEAR, CUBIC, QUINTIC -- don't bother using iterations > 1
      # with LINEAR, as LINEAR is a no-op.
      #
      # The iteration count is how many times to stretch the value in successtion.
      function:   cubic
      iterations: 3
  controls:
    exit:
      # Position is which of the control buttons to use for the kick-in-the-head function.
      position: mixer
    intensity:
      # This is the set of controls for adjusting the intensity of the lights.
      # You should define one position for each Philips Hue Bridge (as this is
      # controlled via a group message to all lights).  The size defines the
      # height or width of the widgets (depending on choice of
      # vertical/horizontal slider), so leave room for one button per value
      # when you compute your y coordinates (or x for horizontal).
      widget: SparkleMotion::LaunchPad::Widgets::VerticalSlider
      positions:
        - [0, 2]
        - [1, 2]
        - [2, 2]
        - [3, 2]
        - [4, 2]
      lights:
        - [ 0,  1,  2,  3,  4,  5,  6] # Strand 1, Group 1 (Bridge 1)
        - [ 9, 10, 11, 12, 13, 14, 15] # Strand 1, Group 2 (Bridge 2)
        - [18, 19, 20, 21, 22, 23, 24] # Strand 2, Group 1 (Bridge 3)
        - [27, 28, 29, 30, 31, 32, 33] # Strand 2, Group 2 (Bridge 4)
        - [ 7,  8, 16, 17, 25, 26, 34, 35] # Dance Lights (Bridge 1..4)
      values:
        # [Mid-point, delta].  Minimum brightness is `mid-point - delta` and max
        # is `mid-point + delta`.
        # - [0.000, 0.000]
        - [0.200, 0.075]
        - [0.300, 0.100]
        - [0.400, 0.150]
        - [0.500, 0.175]
        - [0.600, 0.200]
        - [0.700, 0.300]
    saturation:
      # The desaturation controller.  As above, it's one control per bridge and
      # the `size` defines the height/width of the control.
      #
      # Transition time is how quickly to transition the saturation.  I suggest
      # not going too quickly because while the saturation is updated en masse
      # via group update, the brightness is done per-bulb in the main rendering
      # loop -- and you probably don't want to blind everyone during the
      # transition time.
      widget: SparkleMotion::LaunchPad::Widgets::HorizontalSlider
      transition: 0.5
      positions:
        - [5, 7]
        - [5, 6]
        - [5, 5]
        - [5, 4]
        - [5, 3]
      positions_no:
        - [0, 0]
        - [1, 0]
        - [2, 0]
        - [3, 0]
      # This defines which Hue Bridge, and which group on that bridge a control
      # should affect.  It would be a bit nonsensical if this didn't correspond
      # to the arrangement of lights for the intensity controls though.
      groups:
        - - ["Bridge-01", "AccentMain"]
        - - ["Bridge-02", "AccentMain"]
        - - ["Bridge-03", "Main"]
        - - ["Bridge-04", "Main"]
        - - ["Bridge-01", "Dance"]
          - ["Bridge-02", "Dance"]
          - ["Bridge-03", "Dance"]
          - ["Bridge-04", "Dance"]
      values:
        # Values are [saturation, maximum brightness] -- and null means "don't
        # clamp brightness"
        - [0.2, 0.00]
        # - [0.4, 0.10]
        - [0.6, 0.30]
        # - [0.8, 0.70]
        - [1.0, null]
    spotlighting:
      class: SparkleMotion::LaunchPad::Widgets::RadioGroup
      # This defines the spotlighting effect.  The width and height of the
      # widget are defined by the `mappings` configuration.  The choice of
      # widget class is not configurable because at the moment there's only
      # one option that will work.
      position: [0, 0]
      base:     0.9
      exponent: 2
      mappings:
        # NOTE: Values are indexes into main_lights array.
        #
        # Excluding outermost lights because they extend beyond the seating area.
        # This configuration gives two rows, one corresponding to each of the two
        # light strands I'm putting up.
        #
        # TODO: Automatically suss out lights by using padding / widget size settings and spreading
        # TODO: across the simulations.
        #
        # Bridge 3/4:
        - [20, 21, 22, 23,   24, 27, 28, 29]
        # Bridge 1/2:
        - [ 4,  5,  6,  9,   10, 11, 12, 13]
# TODO: Reallocate accent lights.
# TODO: Either break white lights up across bridges, or consolidate them to Bridge-01 -- I'm... not really sure which.
# TODO: Brightness controls for eating lights.
# TODO: X/Y mapping of lights vs. simulation.
# TODO:   Is time Z, or do we still slide across X?
# TODO: Rearrange lights to evenly disperse A19s.
# TODO: Document bunching configuration on physical deployment.
# TODO: Document on-site validation process, including testing of all spotlighting positions.
# TODO: Document DHCP setup and use of nmap in case I forget Minbar again!!

# TODO: Group all writes to a particular bridge into a single thread.
# TODO: Either self-tune delays, or avoid sending refreshes to each light/group too fast?
# TODO: Play with X multiplier for Perlin component to see if that makes the lighting more visually interesting.
# TODO: Way to tweak output transition time on the fly?  Maybe make this part of the intensity?
# TODO: Way to tweak sweep transition time on the fly?  Maybe make this part of the intensity?
# TODO: De-duplicate the command queue before running it, and run it in a reliable way (E.G. retries with backoff)
# TODO:   If multiple entries exist in-queue for a bridge/group, collapse them together.

# TODO: Finish simulation visualization tool.  (Needs debugging!)
# TODO: Interactive tool for testing bulb positioning. (Be able to blink a specific light)
# TODO: Handy for persistence? http://ruby-doc.org/stdlib-2.2.3/libdoc/yaml/rdoc/YAML/Store.html
