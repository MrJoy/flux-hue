#!/usr/bin/env ruby
# Benchmarks:
#   Baseline:         0.16..0.20
#   Heap Slot Tuning: 0.15..0.20

# def bench_init!; @first_time = @last_time = Time.now.to_f; end

# def bench_snap!(depth = 0)
#   t = Time.now.to_f
#   elapsed = t - @last_time
#   @last_time = t
#   key = caller[depth].split(":")[0..1].join(":").split("/").last
#   key = "TOTAL" if depth > 0
#   puts "%s => %f sec (@%f)" % [key, elapsed, t]
# end

# def bench_end!
#   @last_time = @first_time
#   bench_snap!(2)

#   # From: http://eng.rightscale.com/2015/09/16/how-to-debug-ruby-memory-issues.html
#   GC.start # Start a full garbage collection
#   s = GC.stat # Take a snapshot of the gc status
#   recommended_slots = GC.stat(:heap_live_slots) * (s[:old_objects] / s[:heap_live_slots].to_f)

#   puts s.inspect
#   puts "Recommended heap slots: #{recommended_slots}"
# end

# TODO: Run update across nodes from back to front for simulation rather than
# TODO: relying on a call-chain.  This should make it easy to eliminate the
# TODO: `yield` usage and avoid associated allocations.

# TODO: Deeper memory profiling to ensure this process can run for hours.

# TODO: Pick four downlights for the dance floor, and treat them as a separate
# TODO: simulation.  Consider how spotlighting and the like will be relevant to
# TODO: them.

#   f = Fiber.new do
#     meth(1) do
#       Fiber.yield
#     end
#   end
#   meth(2) do
#     f.resume
#   end
#   f.resume
#   p Thread.current[:name]

###############################################################################
# Early Initialization/Helpers
###############################################################################
bench_init! if defined?(bench_init!)
lib = File.expand_path("../../lib", __FILE__)
$LOAD_PATH.unshift(lib) unless $LOAD_PATH.include?(lib)
require "sparkle_motion"
require "set"

SparkleMotion.init!
SparkleMotion.use_config!
# We load the following unconditionally because so much plugs into the graph
# we don't currently have a good way of decoupling things gracefully.  So all
# USE_GRAPH=0 really means is that we don't run the simulation thread.
SparkleMotion.use_graph!

# Code loading / modular behavior configuration:
USE_LIGHTS  = env_bool("USE_LIGHTS")
USE_INPUT   = env_bool("USE_INPUT")
SKIP_INPUTS = Set.new((ENV["SKIP_INPUTS"] || "").split(/\s*,\s*/).map(&:upcase))
USE_SWEEP   = env_bool("USE_SWEEP")
USE_GRAPH   = env_bool("USE_GRAPH")
SparkleMotion.use_hue!(api: true)
SparkleMotion.use_widgets!
SparkleMotion.use_input! if USE_INPUT

# Crufty common code:
require "sparkle_motion/simulation/parameters"
require "sparkle_motion/simulation/output"
require "sparkle_motion/simulation/command_queue_task"
require "sparkle_motion/simulation/render_task"
require "sparkle_motion/simulation/surface_master_task"
require "sparkle_motion/simulation/graph_task"
require "sparkle_motion/simulation/graph_set"
require "sparkle_motion/simulation/sweeper_task"
require "sparkle_motion/simulation/sweeper_set"
extend SparkleMotion::Simulation::Output
extend SparkleMotion::Hue::HTTP

###############################################################################
# Profiling and Debugging
###############################################################################
LOGGER        = SparkleMotion.logger
profile_run   = ENV["PROFILE_RUN"]
PROFILE_RUN   = (profile_run != "") ? profile_run : nil
SKIP_GC       = env_bool("SKIP_GC")
DEBUG_FLAGS   = Hash[(ENV["DEBUG_NODES"] || "")
                     .split(/\s*,\s*/)
                     .map(&:upcase)
                     .map { |nn| [nn, true] }]

###############################################################################
# Shared State Setup
###############################################################################
# TODO: Run all simulations, and use a mixer to blend between them...
num_lights         = CONFIG["light_groups"]["main_lights"].length
LIGHTS_FOR_THREADS = SparkleMotion::LightConfig.new(config: CONFIG, group: "main_lights")
if USE_INPUT
  controllers = {}
  CONFIG["controllers"].each do |name, config|
    next if SKIP_INPUTS.include?(name.upcase)
    klass = config.delete("class")
    controllers[name] = Kernel.const_get(klass).new(config)
  end
  INTERACTIONS = controllers
else
  INTERACTIONS = {}
end

###############################################################################
# Operational Configuration
###############################################################################
ITERATIONS                = env_int("ITERATIONS", true) || 0
TIME_TO_DIE               = [false, :terminate]

class Simulator
  include SparkleMotion::Hue::HTTP
  attr_accessor :command_queue

  def initialize(interactions, state, logger)
    @interactions   = interactions
    @state          = state
    @logger         = logger
    @command_queue  = SparkleMotion::Simulation::CommandQueueTask.new(logger) if USE_LIGHTS
    bb              = CONFIG["bridges"]
    @sweeper_set    = SparkleMotion::Simulation::SweeperSet.new(bb, @command_queue, @logger)
    @graph_set      = SparkleMotion::Simulation::GraphSet.new(@logger)
    @screen_set     = SparkleMotion::Widgets::ScreenSet.new(interactions, @graph_set, state, logger)
    @input_threads  = @interactions
                      .map do |(nn, cc)|
                        SparkleMotion::Simulation::SurfaceMasterTask.new(nn, cc, @logger)
                      end
  end

  def load!(fname)
    instance_eval(File.read(fname), fname)
  end

  def graphs(&callback)
    @graph_set.draw(&callback)
  end

  def sweepers(&callback)
    @sweeper_set.draw(&callback)
  end

  def screens(&callback)
    @screen_set.draw(&callback)
  end

  def screen(name); @screen_set.screens[name]; end

  def start
    without_persistence do
      @state.load!
      @state.init!
    end
    @state.enabled = true
    @input_threads.map(&:start)
    @sweeper_set.start
    @graph_set.start
  end

  def stop
    @graph_set.stop
    @sweeper_set.stop
    @screen_set.stop
    # TODO: Uh, why is this hanging?
    # @input_threads.map(&:stop)
    TIME_TO_DIE[1] = :terminate
    TIME_TO_DIE[0] = true
  end

  def kick!
    @logger.unknown { "Kicking system in the head!" }
    TIME_TO_DIE[1] = :restart
    TIME_TO_DIE[0] = true
  end

  def update_group!(group, transition, data)
    bridge    = CONFIG["bridges"][group[0]]
    group_id  = bridge["groups"][group[1]]
    url       = hue_group_endpoint(bridge, group_id)
    data      = with_transition_time(transition, data)
    req       = SparkleMotion::Hue::LazyRequestConfig.new(@logger, bridge, :put, url) { data }
    @command_queue << req if @command_queue
  end

protected

  def without_persistence(&block)
    prev = @state.enabled
    @command_queue.disable! if @command_queue
    @state.enabled = false
    block.call
  ensure
    @command_queue.enable! if @command_queue
    @state.enabled = prev
  end
end

state = SparkleMotion::Simulation::Parameters.new("/tmp/sparkle-motion.state", LOGGER)
SIM = Simulator.new(INTERACTIONS, state, LOGGER)
SIM.load!("config.rb")
# NODES.each do |name, node|
#   node.debug = DEBUG_FLAGS[name]
# end


###############################################################################
# Profiling Support
###############################################################################
def start_ruby_prof!
  return unless PROFILE_RUN == "ruby-prof"

  SparkleMotion.logger.unknown { "Enabling ruby-prof, be careful!" }
  require "ruby-prof"
  RubyProf.measure_mode = RubyProf.const_get(ENV.fetch("RUBY_PROF_MODE").upcase)
  RubyProf.start
end

def stop_ruby_prof!
  return unless PROFILE_RUN == "ruby-prof"

  result  = RubyProf.stop
  printer = RubyProf::CallTreePrinter.new(result)
  File.open("tmp/results.html", "w") do |fh|
    printer.print(fh, min_percent: 1)
  end
end

###############################################################################
# Main Simulation
###############################################################################
def light_thread!(bridge, transition, global_results, debug, logger)
  lights = LIGHTS_FOR_THREADS.lights[bridge["name"]]

  LOGGER.unknown do
    light_list = lights.map(&:first).join(", ")
    "#{bridge['name']}: Thread will handle #{lights.count} lights (#{light_list})."
  end

  # SparkleMotion::Simulation::RenderTask.new(node:           FINAL_RESULT,
  #                                           bridge:         bridge,
  #                                           lights:         lights,
  #                                           transition:     transition,
  #                                           global_results: global_results,
  #                                           logger:         logger,
  #                                           debug:          debug)
end

def launch_light_threads!(cfg, global_results, debug, logger)
  threads = []
  return [] unless USE_LIGHTS

  transition  = cfg["transition"]
  threads    += LIGHTS_FOR_THREADS.bridges.values.map do |bridge|
    light_thread!(bridge, transition, global_results, debug, logger)
  end

  threads
end

def launch_all_threads!(config, global_results, debug, logger)
  tmp = { lights:  launch_light_threads!(config["simulation"]["output"],
                                         global_results,
                                         debug["OUTPUT"],
                                         logger) }
  tmp.values.map(&:compact!)
  tmp[:all] = tmp.values.flatten.compact
  SIM.start
  tmp
end

def pre_init!
  trap("INT") do
    TIME_TO_DIE[0] = true
    # If we hit ctrl-c, it'll show up on the terminal, mucking with log output right when we're
    # about to produce reports.  This annoys me, so I'm working around it:
    puts
  end
  Thread.abort_on_exception = true
end

def nodes_under_debug
  # NODES.select { |name, _node| DEBUG_FLAGS[name] }
  # TODO: Reimplement me!
  false
end

def debugging?
  # TODO: Reimplement me!
  # nodes_under_debug.length > 0 || DEBUG_FLAGS["OUTPUT"] || PROFILE_RUN
  false
end

def init!(global_results)
  LOGGER.unknown { "Initializing system..." }
  if SKIP_GC
    LOGGER.unknown { "Disabling garbage collection!  BE CAREFUL!" }
    GC.disable
  end
  global_results.begin! if global_results
  start_ruby_prof!
  # FINAL_RESULT.update(Time.now.to_f)
end

def wake!(threads)
  LOGGER.unknown { "Final setup done, waking threads..." }
  threads.each(&:start)
end

def spin!(threads)
  LOGGER.unknown { "Waiting for the world to end..." }
  loop do
    # Someone hit the exit button:
    break if TIME_TO_DIE[0]
    # We went through and did `ITERATIONS` update loops over the lights:
    # ... the `- 1` is for the command queue thread!
    unfinished = (threads.length - threads.count { |th| th.status == false }) - 1
    break if USE_LIGHTS && unfinished == 0
    sleep 0.25
  end
end

def stop!(threads)
  LOGGER.unknown { "Stopping threads..." }
  %i(lights).each do |thread_group|
    threads[thread_group].each(&:stop)
  end
  threads[:all].map(&:await)
end

def main
  pre_init!

  announce_iteration_config(ITERATIONS)

  global_results  = SparkleMotion::Results.new(logger: LOGGER) if defined?(SparkleMotion::Results)
  threads         = launch_all_threads!(CONFIG, global_results, DEBUG_FLAGS, LOGGER)

  init!(global_results)
  wake!(threads[:all])
  spin!(threads[:lights])
  stop!(threads)

  LOGGER.unknown { "Doing final shutdown..." }
  global_results.done! if global_results
  SIM.stop

  print_results(global_results) if global_results
  dump_debug_data!
end

def profile!(&block)
  unless PROFILE_RUN == "memory_profiler"
    block.call
    return
  end

  LOGGER.unknown { "Enabling memory_profiler, be careful!" }
  require "memory_profiler"
  report = MemoryProfiler.report do
    block.call
    LOGGER.unknown { "Preparing MemoryProfiler report." }
  end
  LOGGER.unknown { "Dumping MemoryProfiler report." }
  # TODO: Dump this to a file...
  report.pretty_print
end

###############################################################################
# Launcher
###############################################################################
profile! do
  bench_end! if defined?(bench_end!)
  main
end

exit 127 if TIME_TO_DIE[1] == :restart
